📘 DGFS 기술 명세서: 코드 구조 및 로직 흐름 (Ver 4.4)
1. 모듈별 상세 역할 정의 (Module Roles)
DGFS 프로젝트는 관심사의 분리(Separation of Concerns) 원칙에 따라 8개의 핵심 모듈로 확장 구성되어 있습니다.
1.1. config.py (Configuration)
역할: 게임의 **'상수(Constants) 저장소'**이자 '환경 설정 파일'.
핵심 내용:
SCREEN_WIDTH, FPS: 해상도(1280x720) 및 프레임 설정.
WHITE, RED, GRAY: UI 및 체력바에 사용되는 색상 RGB 값.
BASE_DIR, ASSETS_DIR: OS 독립적인 절대 경로 계산.
중요성: 모든 파일이 참조하며, 해상도나 경로 변경 시 이 파일만 수정하면 전역 반영됩니다.
1.2. database.py (Data Access Layer)
역할: '데이터 관리자'. 기획 데이터(CSV)와 인게임 데이터(SQLite) 사이의 브리지 역할을 수행합니다.
핵심 업데이트:
 init_db(): 게임 시작 시 DB 스키마를 정의하고, CSV 데이터를 로드합니다.
  - [New] 개발 편의를 위해 `inventory` 테이블을 매번 삭제 및 재생성합니다.
  - [New] `inventory`가 비어있을 경우, 테스트용 기본 캐릭터 2명을 자동 지급합니다.
 스키마 확장:
  - users: `current_floor` (이어하기를 위한 현재 층수).
  - inventory: `current_hp`, `current_mp`, `current_sp`, `current_atk`, `current_max_hp` (캐릭터별 스탯 저장을 위한 컬럼).
1.3. ui/components.py (UI Library)
역할: 재사용 가능한 'UI 부품 공장'.
핵심 클래스:
 Button: 마우스 오버/클릭 이벤트를 처리하는 버튼 객체. [New] `color`, `hover_color` 인자를 받아 다양한 색상의 버튼을 생성할 수 있도록 확장되었습니다.
InputBox: 쿠폰 입력 등에 사용되는 텍스트 입력 필드.
1.4. game_systems/battle.py (Core Logic Engine)
역할: **'전투 엔진'**이자 '로그라이크 룰 관리자'.
핵심 로직:
 init_party(): 전투 시작 시 파티 정보를 구성합니다.
  - [New] DB의 `current_floor`를 읽어와 현재 층을 설정합니다.
  - [New] `inventory`의 `current_hp` 등 저장된 스탯을 우선적으로 로드하여 '이어하기'를 구현합니다.
  - [New] 선택된 캐릭터가 없을 경우, 인벤토리의 캐릭터 2명을 자동으로 선택하여 튜토리얼 반복 진입을 방지합니다.
 save_party_status(): 전투 종료 또는 '저장하고 나가기' 시, 현재 파티의 HP/MP/SP를 메모리(`party_data`)에 임시 저장합니다. (DB 저장은 `main.py`에서 담당)
 process_reward(): 전투 승리 보상(스탯 강화, 회복, 티켓)을 처리하고 다음 층으로 이동(`floor += 1`)합니다.
1.5. game_systems/stage_manager.py (Stage Logic) [New]
역할: '맵 생성기'. 100층 등반의 바이옴 순서와 적 난이도를 제어합니다.
핵심 로직 (get_stage_info):
Biome Shuffle: 30층 단위(Phase)로 바이옴 순서를 랜덤하게 섞음.
Tier Scaling: 층수에 따라 적의 등급(Tier 1~3)을 결정.
Boss Spawning: 10층 단위 및 90층 이상 구간의 고정/랜덤 보스 출현 관리.
1.6. game_systems/gacha.py (Economy System) [New]
역할: '확률형 아이템 생성기'.
핵심 로직:
 draw_1() / draw_10(): 등급별 가중치에 따라 1회 또는 10회 캐릭터를 추첨합니다.
Inventory Save: 뽑힌 캐릭터를 DB inventory 테이블에 즉시 저장.
1.7. game_systems/coupon.py (Economy System)
역할: '오프라인 보상 검증기'.
로직: DAD251201N 형식의 코드를 파싱하여 유효성을 검증하고 티켓을 지급.
1.8. main.py (Application Entry Point)
역할: '지휘자(Conductor)'. 게임의 상태(State) 관리 및 화면 전환.
상태 관리 (game_state): "LOBBY", "BATTLE", "DECK_VIEW", "COUPON_POPUP", "GACHA_SHOP" 등 게임의 모든 화면 상태를 제어합니다.
핵심 함수:
 - save_run_state(): `battle_scene`의 데이터를 받아 DB에 현재 층과 캐릭터 스탯을 영구 저장합니다.
 - reset_run_state(): DB의 `current_floor`와 `inventory`를 초기화하여 '새로 시작' 기능을 구현합니다.
UI 흐름 제어:
 - 로비: '새로 하기', '이어하기' 버튼을 통해 게임 시작 흐름을 분기합니다.
 - 소환상점: `gacha_shop_mode` 내부 상태("SELECT" / "RESULT")를 통해, 화면 전환 없이 뽑기 선택과 결과 확인이 모두 이루어집니다.
 - 팝업 시스템: '새로 시작' 확인 등 사용자에게 중요한 확인을 받는 팝업창을 렌더링합니다.
2. 코드 실행 및 로직 흐름도 (Execution Flow)
2.1. 게임 시작 (Startup Sequence)
main.py 실행 → init_db() (DB 스키마 생성, CSV 로드, 기본 캐릭터 지급) → 로비 진입.
2.2. 새로 시작 / 이어하기 (Game Start Flow)
새로 시작: `reset_run_state()` 호출 (DB 초기화) → `init_db()` 재호출 (기본 캐릭터 지급) → `BattleScene` 생성 (1층부터 시작).
이어하기: `BattleScene` 생성 → `init_party()`가 DB의 `current_floor`와 `current_hp` 등 저장된 상태를 로드.
2.3. 소환 (Gacha Flow)
로비 [소환상점] 클릭 → `GACHA_SHOP` 상태 진입 → [10회 소환] 클릭 → `GachaManager.draw_10()` 호출 및 `inventory` 저장 → `gacha_shop_mode`를 "RESULT"로 변경하여 동일 화면에 결과 출력.
2.3. 전투 루프 (Battle Loop)
Init: BattleScene 생성.
Party Load: DB에서 is_selected=1인 캐릭터 로드 (없으면 인벤토리에서 2명 강제 선택).
Enemy Spawn: StageManager가 결정한 Biome/Tier/Role에 맞춰 DB에서 적 소환.
Battle:
턴 큐(Turn Queue)에 따라 공격 진행.
사망한 아군은 fighters 목록에서 제외 (전투 불능).
End Game:
승리: 보상 선택(HP/스탯) → `floor += 1` → 다음 층 적 생성.
보스 클리어: 10층 단위 승리 시 full_restore_party() 발동.
패배: 아군 전멸 시 `reset_run_state()` 호출 (진행상황 초기화) 후 로비로 복귀.
저장하고 나가기: `save_run_state()` 호출 (진행상황 저장) 후 로비로 복귀.
2.4. 향후 개발 과제 (Phase 4 Requirement)
레벨업 시스템: 중복 캐릭터 획득 시 경험치나 재화로 변환하여 기존 캐릭터를 성장시키는 시스템 구현.
시각 효과 강화: 소환 결과 화면에 실제 캐릭터 이미지 렌더링, 스킬 사용 시 화면 흔들림 등 연출 추가.
